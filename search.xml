<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何优雅地通过字符串动态调用函数]]></title>
      <url>http://namco1992.github.io/2016-06-12-how-to-call-function-by-string.html</url>
      <content type="html"><![CDATA[<p>前一段时间为公司的业务写了一个非常轻量级的监控平台，最近抽出空来整理一下思路。首先从一个小 trick 开始吧。</p>
<h2 id="scrapy-中的-item-pipeline"><a href="#scrapy-中的-item-pipeline" class="headerlink" title="scrapy 中的 item pipeline"></a>scrapy 中的 item pipeline</h2><p>我写的监控平台的 pipeline 机制主要模仿了 scrapy 中的 item pipeline。 在 scrapy 的配置文件中，pipeline 的配置表示方式是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'myproject.pipelines.FirstPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">'myproject.pipelines.SecondPipeline'</span>: <span class="number">800</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ITEM_PIPELINES</code>作为一个字典，<code>key</code>就是处理类的路径，<code>value</code>值的大小则代表了该 pipeline 的优先级。<br><a id="more"></a></p>
<p>我们的监控平台远没有 scrapy 这么复杂，因此就只需要一个列表，根据列表顺序依次执行函数就可以了。于是问题来了。(学挖掘机哪家强？)我们如何像 scrapy 一样通过字符串表示的路径来读取出相应的类或者函数呢？</p>
<h2 id="importlab-的使用"><a href="#importlab-的使用" class="headerlink" title="importlab 的使用"></a>importlab 的使用</h2><p>其实非常简单，我们只需要使用<code>importlib</code>来引入对应的包就可以了。如果需要返回具体的执行函数，就利用<code>getattr</code>。具体代码示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_attribute</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="string">"""Return an attribute from a dotted path name (e.g. "path.to.func")."""</span></span><br><span class="line">    module_name, attribute = name.rsplit(<span class="string">'.'</span>, <span class="number">1</span>)</span><br><span class="line">    module = importlib.import_module(module_name)</span><br><span class="line">    <span class="keyword">return</span> getattr(module, attribute)</span><br><span class="line"></span><br><span class="line">func = import_attribute(<span class="string">'monitor_platform.src.pipelines.common_pipeline.send_mail'</span>)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure></p>
<p>在主线程中，调用<code>import_attribute</code>，首先<code>.rsplit</code>将包名与属性名分离，然后通过<code>importlib.import_module</code>引入包，最后通过<code>getattr</code>获取到该属性，此时获取到的<code>func</code>就是我们希望执行的函数了。只要提供一个 pipeline 的列表，就可以依次引入，顺序执行。就是这么简单。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从 Flask 中视图函数说开来]]></title>
      <url>http://namco1992.github.io/2016-06-12-tips-about-flask-view-function.html</url>
      <content type="html"><![CDATA[<p>自从夸下海口从朋友那里接下私活，就开始抽空看看有关 Flask 的东西。还记得刚入职的时候学习 Django，只是 Tutorial 那几个小教程就翻来覆去看了几遍，最终还是有些一头雾水，又觉得过于繁杂，索性就算了。这次也趁此机会把 Flask 上手一下，也越发理解了为什么有人说“自定义的 Flask 最终也会变成一个 Django”，可能后面有时间再去把 Django 拾起来就没那么困难了。</p>
<p>上面都是题外话，下面需要说的是一个关于 Flask 的一个小细节，首先我们需要明确一下在 Flask 中路由功能的实现过程是怎样的。<br><a id="more"></a></p>
<h2 id="Flask-中的路由"><a href="#Flask-中的路由" class="headerlink" title="Flask 中的路由"></a>Flask 中的路由</h2><h3 id="route注册路由"><a href="#route注册路由" class="headerlink" title="route注册路由"></a><code>route</code>注册路由</h3><p>在 Flask 中的路由注册是有多种方式的，在这里我们只介绍使用<code>route</code>装饰器的注册方式。一言以蔽之，Flask  中<code>route</code>的作用就是建立url与处理函数的映射。</p>
<p>通过阅读官方的 API 文档可以得知，<code>route</code>函数所必需的参数只有一个，我们只介绍一下常用参数。</p>
<ol>
<li><code>rule</code>，必选参数。通过<code>rule</code>来指定该视图函数所对应的 url 地址。</li>
<li><code>endpoint</code>，就是url和处理函数映射关系中的一个中介。在 Flask 中一个路由的过程是这样的：rule –&gt; endpoint –&gt; view function。<code>endpoint</code>这个参数通常会被忽略，当 <code>endpoint</code>未指定时，Flask 会为其指定一个默认名，就是视图函数的名称。当然，你也可以显式指定<code>endpoint</code>。</li>
<li><code>methods</code>，用于指定接受的请求方式。</li>
</ol>
<p>综上，一般你会看到一个视图函数用以下方式进行路由注册：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># whatever you want</span></span><br></pre></td></tr></table></figure></p>
<h3 id="view-functions与url-map"><a href="#view-functions与url-map" class="headerlink" title="view_functions与url_map"></a><code>view_functions</code>与<code>url_map</code></h3><p>这两个就是深入底层的 Flask 的路由注册最关键的两个变量。其中：</p>
<ul>
<li><code>Flask.url_map</code>保存所有的 (url, endpoint, method) 映射关系，是 werkzeug 中自己实现的一个<code>Map</code>对象。</li>
<li><code>Flask.view_functions</code>保存所有的 {endpoint: function} 映射关系，本质就是一个字典对象。<br>Flask 接收到请求之后，由<code>url_map</code>解析到对应的 <code>ednpoint</code>，然后通过<code>view_functions</code>的映射找到对应的视图函数，最终调用指定的函数，完成路由。</li>
</ul>
<h2 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h2><p>根据上文的分析，在<code>url_map</code>中，我们的<code>url</code>和<code>endpoint</code>都必须是唯一的。一个<code>url</code>，只能够对应一个 <code>endpoint</code>，必然也就只能对应一个视图函数，是一个一一对应的关系。而视图函数可以注册多个路由，是一个一对多的关系。这一点的理解对于我们下文要指出的问题非常关键。</p>
<h2 id="如何在-Flask-中的视图函数上使用装饰器"><a href="#如何在-Flask-中的视图函数上使用装饰器" class="headerlink" title="如何在 Flask 中的视图函数上使用装饰器"></a>如何在 Flask 中的视图函数上使用装饰器</h2><p>对于装饰器，如果还有读者不了解的话，可以阅读一下<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000" target="_blank" rel="external">廖雪峰的教程</a>，其中关键的一点是对<code>functools.wraps</code>的使用。然而像我这样平时不太在乎这个函数签名问题的人，可能会写出下面这种代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorater</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Do something</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p><strong>然而，如果你在 Flask 中用于视图函数的装饰器也这么写的话，就会出现以下异常：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssertionError: View function mapping <span class="keyword">is</span> overwriting an existing endpoint function</span><br></pre></td></tr></table></figure></p>
<p>这是为什么呢？</p>
<p>因为我们上文介绍过了，如果没有显式指定<code>endpoint</code>的时候，会默认使用视图函数的<code>__name__</code>属性作为<code>endpoint</code>的值，并且放在映射表中。原本视图函数的名称是<code>func.__name__</code>，而使用了上述装饰器之后，因为所返回的变成了<code>wrapper</code>函数，所以你的视图函数名称就变为了<code>wrapper.__name__</code>。当你针对多个视图函数使用了装饰器之后，在flask 的<code>user_map</code>中会造成<code>endpoint</code>的函数名冲突，进而抛出异常。</p>
<p>所以基本功要扎实，<code>functools.wraps</code>就是用来把被包装的函数名称原封不动地返回，以确保像 Flask 中这样依赖于函数名称的某些代码可以正常执行。因此，一个正确的写法应该是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorater</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Do something</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p>这样你的代码就可以正常运行了，当你检查<code>url_map</code>时会发现<code>endpoint</code>和视图函数一切正常。</p>
<h2 id="我为什么要在-Flask-中使用装饰器？"><a href="#我为什么要在-Flask-中使用装饰器？" class="headerlink" title="我为什么要在 Flask 中使用装饰器？"></a>我为什么要在 Flask 中使用装饰器？</h2><p>装饰器这个特性可以极大地降低我们代码的复杂度，同时也提高了代码的复用性。因为视图函数作为“MVC”模型中的“C”，有着承上启下的作用，负责链接数据层与视图。在 Flask 中，很多有用的插件都使用装饰器的方式为视图函数增加功能，即优雅有便捷。比如说：</p>
<ul>
<li><a href="https://flask-login.readthedocs.org/" target="_blank" rel="external">Flask-Login</a> 中常见的<code>@login_required</code>，检查是否满足已登陆条件</li>
<li><a href="https://pythonhosted.org/Flask-Cache/" target="_blank" rel="external">Flask-Cache</a> 中用于缓存数据等等。</li>
</ul>
<p>例子很多，不一而足。</p>
<p>当然，这些优秀插件只是免除了我们一部分造轮子的麻烦，为我们提供了某些解决问题的思路。但是有些小功能你也可以自己来实现。比如说在 Flask 中，作为主要逻辑处理的视图函数并没有相应的“try-catch”机制，因此很多时候即便是开启了 debug 模式也不能捕获发生在 视图函数中的所有异常。这让我曾经的调试一度非常痛苦。后来才想起使用装饰器可以非常简单地解决这个问题，也真算是后知后觉了。大概的思路如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_exception</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    Since the flask does not provide a function for catching and analysing</span><br><span class="line">    the exceptions, it's difficult that knowing what happened on the fly.</span><br><span class="line">    If you decorate a view with this, the wrapper can handle the exceptions</span><br><span class="line">    and log it automatically.</span><br><span class="line"></span><br><span class="line">    :param func: The view function to decorate.</span><br><span class="line">    :type func: function</span><br><span class="line">    '''</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated_view</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            current_app.logger.warn(traceback.format_exc())</span><br><span class="line">            <span class="keyword">return</span> abort(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">return</span> decorated_view</span><br></pre></td></tr></table></figure></p>
<p>这里只是提供了一个简单的思路：只要把这个装饰器用于视图函数，并且设置好 logger 的 handler，就可以捕获所有在视图函数执行过程中发生的异常并且记录下来。<br>这里的代码其实是有一点小问题的，因为在 Flask 中<code>abort</code>的实现是继承了<code>HTTPException</code>的一个异常抛出，所以上面的代码会把<code>abort</code>也作为异常捕获到，并且重新抛出 500，这样会在某些场景下产生困惑。比如说一个简单的 404 却被展示成服务器错误。这点小问题就留给有兴趣的读者来解决好了 :)</p>
<p>参考文章：</p>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000003875420" target="_blank" rel="external">https://segmentfault.com/q/1010000003875420</a><br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[不停机条件下部署 Django 应用]]></title>
      <url>http://namco1992.github.io/2015-12-09-deploying-a-django-app-with-no-downtime.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文由 伯乐在线 - Namco 翻译，jasper 校稿。未经许可，禁止转载！<br>英文出处：healthchecks。欢迎加入翻译组。</p>
</blockquote>
<p>当我们上线新的服务应用时，经常不得不重启Web服务器以完成部署。但这会对用户造成一定影响，特别是服务器处于繁忙状态时，问题更严重。本文中，作者将针对这一问题，讲述其如何在不停机条件下部署Django应用。<br><a id="more"></a></p>
<p>当我的网站 healthchecks.io 每秒接收的请求次数超过一次之后，我就非常清楚地认识到我不能再像以前那样部署代码之后随意重启 web 服务器了。作为一个监控服务，哪怕是漏掉几条 HTTP 的请求也是不能接受的。并且随着时间推移，服务器越来越忙碌，这个问题只会更严重。</p>
<p>先让我简单介绍一下我在做什么吧：我在做的 app 是一个相对简单的 Django app，搭建在 gunicorn 的 WSGI 服务上，使用 nginx 作为代理服务器，而数据存储在 PostgreSQL 数据库上。gunicorn 进程和一个附加的后台作业都由 supervisor 管理。app 主机是一台区区 20 美元的 DigitalOcean 服务器。</p>
<p>另外，鉴于当前技术选择的日新月异，我遵循的指导原则就是保证技术栈尽可能长时间地保持简单和可扩展。添加一些诸如负载均衡、数据库复制、键值对存储、消息队列等等的功能，这些功能的确都能带来某些益处。然而从另一方面来讲，这也意味着有更多东西需要管理、监控和备份。同时对于参与项目的新人来说，他们不得不花更多时间弄清楚系统的数据流向，从头开始建立起所有的东西。我认为在不牺牲性能和特性的前提下，能够保持简单不冗余的架构是一种有趣的挑战。</p>
<p>我使用的部署机制是 Fabric 脚本加上 supervisor 和 nginx 的配置模板。每次我在工作站上运行 “fab deploy”命令时，Fabric 脚本会在远程服务器上完成如下事项：</p>
<ul>
<li>为新的部署创建一个目录，姑且将之称为 $TARGET。</li>
<li>在 $TARGET/venv 目录下建立一个 python3 的虚拟环境。</li>
<li>从 GitHub 上抓取最新的代码快照到你的$TARGET目录。你可以使用 GitHub 的 SVN 接口运行“svn export”命令完成这项操作，非常简便。这项操作如你所愿地只是生成了源文件，但是没有任何版本控制的元数据。</li>
<li>根据 requirements 文件安装依赖包。这些依赖包会安装在虚拟环境下而不会影响现有应用。下载和安装依赖包大概需要一分钟（这里的时间估算应当针对国外环境，国内的网络状况，你懂的 :) 译者注。）</li>
<li>运行 Django 管理命令收集静态文件，执行数据库迁移等等准备工作。</li>
<li>重写 supervisor 的配置文件，在新的虚拟环境下运行 gunicorn。</li>
<li>更新 nginx 配置文件，以防改动过 nginx 配置模板中的某些配置没有生效。</li>
<li>运行 “supervisorctl reload” 和“/etc/init.d/nginx restart”。当前 web 应用还是不能访问的，直到 supervisor 开始运行，启动 gunicorn 进程并且初始 Django 代码完成之后才能访问。这个过程通常需要 5 至 10秒，在这期间 nginx 一般会返回 “502 Bad Gateway”。</li>
<li>大功告成！</li>
</ul>
<p>下面是相关的 Fabric 脚本代码示例。脚本中使用的虚拟环境上下文管理器（virtualenv context manager）来源于非常棒的 fabtools 库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deploy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Checks out code, prepares venv, runs management commands,</span><br><span class="line">    updates supervisor and nginx configuration. """</span></span><br><span class="line"></span><br><span class="line">    now = datetime.datetime.today()</span><br><span class="line">    now_string = now.strftime(<span class="string">"%Y%m%d-%H%M%S"</span>)</span><br><span class="line">    project_dir = <span class="string">"/home/hc/webapps/hc-%s"</span> % now_string</span><br><span class="line">    venv_dir = os.path.join(project_dir, <span class="string">"venv"</span>)</span><br><span class="line"></span><br><span class="line">    svn_url = <span class="string">"https://github.com/healthchecks/healthchecks/trunk"</span></span><br><span class="line">    run(<span class="string">"svn export %s %s"</span> % (svn_url, project_dir))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> cd(project_dir):</span><br><span class="line">        run(<span class="string">"virtualenv --python=python3 --system-site-packages venv"</span>)</span><br><span class="line">        <span class="comment"># local_settings.py is where things like access keys go</span></span><br><span class="line">        put(<span class="string">"local_settings.py"</span>, <span class="string">"."</span>)</span><br><span class="line">        put(<span class="string">"newrelic.ini"</span>, <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> virtualenv(venv_dir):</span><br><span class="line">            run(<span class="string">"pip install -U gunicorn raven newrelic"</span>)</span><br><span class="line">            run(<span class="string">"pip install -r requirements.txt"</span>)</span><br><span class="line">            run(<span class="string">"python manage.py collectstatic --noinput"</span>)</span><br><span class="line">            run(<span class="string">"python manage.py compress"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> settings(user=<span class="string">"hc"</span>):</span><br><span class="line">                run(<span class="string">"python manage.py migrate"</span>)</span><br><span class="line">                run(<span class="string">"python manage.py ensuretriggers"</span>)</span><br><span class="line">                run(<span class="string">"python manage.py clearsessions"</span>)</span><br><span class="line"></span><br><span class="line">    switch(project_dir)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch</span><span class="params">(project_dir)</span>:</span></span><br><span class="line">    <span class="comment"># Supervisor</span></span><br><span class="line">    upload_template(<span class="string">"supervisor/hc.conf.tmpl"</span>,</span><br><span class="line">                    <span class="string">"/etc/supervisor/conf.d/hc.conf"</span>,</span><br><span class="line">                    context=locals(),</span><br><span class="line">                    backup=<span class="keyword">False</span>,</span><br><span class="line">                    use_sudo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    upload_template(<span class="string">"supervisor/hc_sendalerts.conf.tmpl"</span>,</span><br><span class="line">                    <span class="string">"/etc/supervisor/conf.d/hc_sendalerts.conf"</span>,</span><br><span class="line">                    context=locals(),</span><br><span class="line">                    backup=<span class="keyword">False</span>,</span><br><span class="line">                    use_sudo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Nginx</span></span><br><span class="line">    upload_template(<span class="string">"nginx/hc.conf.tmpl"</span>,</span><br><span class="line">                    <span class="string">"/etc/nginx/sites-enabled/hc.conf"</span>,</span><br><span class="line">                    context=locals(),</span><br><span class="line">                    backup=<span class="keyword">False</span>,</span><br><span class="line">                    use_sudo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    sudo(<span class="string">"supervisorctl reload"</span>)</span><br><span class="line">    sudo(<span class="string">"/etc/init.d/nginx reload"</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在问题来了：在每次发布的最后一步怎样尽量避免停机？首先我们先设置如下约束条件：没有负载均衡（至少现在没有）。所有服务运行在一个环境下，尽可能避免一切错误返回。现在我们从最简单的步骤开始。我们先来考虑一种简单的（并且是常见的）场景：不会发生数据库迁移，并且部署的改动是向后兼容的：旧版本的 app 可以在迁移之后正常运行。</p>
<p>我想到的第一个想法是基于这样一个观点：可用性对于 app 的某些部分更为重要，而对于其他部分可能就没那么重要了。具体到我的 app 来说，比如 app 监听客户机发来的 ping 包的 API 接口部分就需要更高的可用性，而给普通访问者提供的前端服务页面部分就没有那么重要了。尽管给访问者返回了错误页面十分尴尬，但是不遗漏任何一个 ping 包才是最重要的。毕竟我们提供的是监控服务，一个丢失的 ping 包可能导致在之后某个时间发出一个假警报——这才是最尴尬的！</p>
<p>我考虑使用亚马逊 API 监听这些 ping 包，并且设计了个原型。它可以把 ping 包信息放在 亚马逊 SQS 队列中，当 Django app 有空闲时再处理。这是一种相对简单的处理方法，大幅提高了可用性和扩展性，但是也是以增加复杂度和添加新的外部依赖为代价的。我可能在之后还需要重新审视一下这个方案。</p>
<p>下一个想法是这样的：把监听 ping 包的功能从原来的 app 中剥离出来。ping 监听的逻辑其实非常简单，最终只相当于两个 SQL 操作：update 和 insert。这一部分代码重构起来非常容易，比如使用一个 python 的微型框架，或者使用其他的语言实现，甚至可以用 nginx 本身的 ngx_postgres 模型来实现。下面提供了基本实现了这个功能的 nginx 配置文件，仅供消遣（忽略掉那个写得很滑稽的正则表达式 :)）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/(wwwwwwww-wwww-wwww-wwww-wwwwwwwwwwww)/?$ &#123;</span><br><span class="line">    add_header Content-Type text/plain;</span><br><span class="line"></span><br><span class="line">    postgres_pass   database;</span><br><span class="line">    postgres_output value;</span><br><span class="line"></span><br><span class="line">    postgres_escape $ip $remote_addr;</span><br><span class="line">    postgres_escape $agent =$http_user_agent;</span><br><span class="line">    postgres_escape $body =$request_body;</span><br><span class="line"></span><br><span class="line">    postgres_query &quot;</span><br><span class="line">        WITH t AS (</span><br><span class="line">            UPDATE api_check</span><br><span class="line">            SET last_ping=now()</span><br><span class="line">            WHERE code=&apos;$1&apos;</span><br><span class="line">            RETURNING id, last_ping</span><br><span class="line">        )</span><br><span class="line">        INSERT INTO api_ping</span><br><span class="line">            (created, remote_addr, method, ua, body, owner_id, scheme)</span><br><span class="line">        SELECT</span><br><span class="line">            last_ping, $ip, &apos;$request_method&apos;, $agent, $body, id, &apos;$scheme&apos;</span><br><span class="line">        FROM t</span><br><span class="line">        RETURNING &apos;OK&apos;</span><br><span class="line">    &quot;;</span><br><span class="line"></span><br><span class="line">    postgres_rewrite no_changes 400;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面配置的执行逻辑是这样的：当用户请求特定格式的 URL 时，服务器会在 PostgreSQL 数据库上查询并且返回，返回码是 200 或者 400。这对性能也是一种提升，因为请求不需要在跑一遍 gunicorn，Django 和 psycopg2 然后才返回了。只要数据库可用，nginx 就可以处理这些 ping 包，即便是 Django 应用意外宕机了也没关系。</p>
<p>然而这种实现方式在某些情况下并非最好选择，这种方式有一定技巧性，并且要求开发者和系统管理员的知识储备要足够丰富才行。举个例子，当数据库模式发生改变，上面的 SQL 查询也需要更新和测试。如果启用了 ngx_postgres 的扩展组件的话，这就不像“apt-get install” 这种操作这么简单了。</p>
<p>我们的主要目的还是达成不停机部署，如果再仔细考虑一下的话，如果能仔细协调好重启和重新加载服务的流程的话，也是可以达成的。</p>
<p>我的部署脚本使用“/etc/init.d/nginx restart”是因为我不知道更好的选择了。但是据我了解，这个命令可以替换成“/etc/init.d/nginx reload”，以实现优雅地重启：</p>
<blockquote>
<p>运行“service nginx reload”或者“/etc/init.d/nginx reload”将会热重载配置从而消除停机时间。如果还有等待的请求，只要连接还没有断开，nginx进程就会接着处理这些连接。因此这是一个非常优雅地重载配置的方式。<br>—— “Nginx config reload without downtime” on ServerFault</p>
</blockquote>
<p>同样的，我的部署脚本使用的“supervisorctl reload”命令会停止所有管理的服务，重新读取配置，最后启动所有服务。而“supervisorctl update”可以按需启动、停止和重启修改后的任务。</p>
<p>改良之后的 “fab deploy” 可以完成以下任务：</p>
<ul>
<li>建立一个新的虚拟环境，和之前一样。</li>
<li>创建一个唯一名称的 supervisor 任务（比如“hc_timestamp”）。</li>
<li>与已经运行的 gunicorn 进程并行启动一个新的 gunicorn 进程。nginx 与使用 UNIX 套接字的 gunicorn 进程通信，每个进程使用单独的，带有时间戳的套接字文件。</li>
<li>等待一段时间，直到新的 gunicorn 进程已启动并且可以正常服务。</li>
<li>更新 nginx 配置文件并且指向新的套接字配置文件，重新加载 nginx。</li>
<li>停掉老的 gunicorn 进程</li>
</ul>
<p>下面是更新之后的 Fabric 脚本，也实现了 supervisor 任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch</span><span class="params">(tag, project_dir)</span>:</span></span><br><span class="line">    <span class="comment"># Supervisor</span></span><br><span class="line">    supervisor_conf_path = <span class="string">"/etc/supervisor/conf.d/hc_%s.conf"</span> % tag</span><br><span class="line">    upload_template(<span class="string">"supervisor/hc.conf.tmpl"</span>,</span><br><span class="line">                    supervisor_conf_path,</span><br><span class="line">                    context=locals(),</span><br><span class="line">                    backup=<span class="keyword">False</span>,</span><br><span class="line">                    use_sudo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    upload_template(<span class="string">"supervisor/hc_sendalerts.conf.tmpl"</span>,</span><br><span class="line">                    <span class="string">"/etc/supervisor/conf.d/hc_sendalerts.conf"</span>,</span><br><span class="line">                    context=locals(),</span><br><span class="line">                    backup=<span class="keyword">False</span>,</span><br><span class="line">                    use_sudo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Starts up gunicorn from the new virtualenv</span></span><br><span class="line">    sudo(<span class="string">"supervisorctl update"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Give it some time to start up</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let's check the new server is nominally working</span></span><br><span class="line">    <span class="comment"># gunicorn listens on UNIX socket so this is a bit contrived:</span></span><br><span class="line">    l = (<span class="string">"GET /about/ HTTP/1.0rn"</span></span><br><span class="line">         <span class="string">"Host: healthchecks.iorn"</span></span><br><span class="line">         <span class="string">"rn"</span>)</span><br><span class="line"></span><br><span class="line">    cmd = <span class="string">'echo -e "%s" | nc -U /tmp/hc-%s.sock'</span> % (l, tag)</span><br><span class="line">    <span class="comment"># Look for known string in response. If it's not found, something</span></span><br><span class="line">    <span class="comment"># is wrong with the new deployment and we abort</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">"Monkey See Monkey Do"</span> <span class="keyword">in</span> run(cmd, quiet=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nginx</span></span><br><span class="line">    upload_template(<span class="string">"nginx/hc.conf.tmpl"</span>,</span><br><span class="line">                    <span class="string">"/etc/nginx/sites-enabled/hc.conf"</span>,</span><br><span class="line">                    context=locals(),</span><br><span class="line">                    backup=<span class="keyword">False</span>,</span><br><span class="line">                    use_sudo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    sudo(<span class="string">"/etc/init.d/nginx reload"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># should be live now - remove supervisor conf for previous versions</span></span><br><span class="line">    s = sudo(<span class="string">"for i in /etc/supervisor/conf.d/*.conf; do echo $i; done"</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> s.split(<span class="string">"n"</span>):</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> line == supervisor_conf_path:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">"/etc/supervisor/conf.d/hc_2"</span>):</span><br><span class="line">            sudo(<span class="string">"rm %s"</span> % line)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This stops gunicorn processes</span></span><br><span class="line">    sudo(<span class="string">"supervisorctl update"</span>)</span><br></pre></td></tr></table></figure>
<p>这样的话 nginx 就可以一直提供服务响应，然后和正在运行的 gunicorn 进程持续保持通信。为了实际验证，我写了一个脚本无限循环地请求特定的 URL。如果得到了一个非正确的返回，就会打印出来一个显眼的错误消息。使用这个脚本不断冲击我的测试虚拟机的同时，我做了一些部署操作，并没有发现丢失的请求。大功告成！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要实现在代码部署时不停机，有很多种方式，每种方式都要权衡利弊。比如说一个合理的策略是把关键部分从原来的应用中剥离出来，每个部分都可以独立更新。之后每个部分也可以独立扩展。但是这种策略的缺点就是有更多的代码和配置需要维护。</p>
<p>最终我达成的效果是：</p>
<p>热重载 supervisor 和 nginx 配置，而不是直接重启它们。根据之前的经验，这种做法的好处是显而易见的。<br>在停止旧的 gunicorn 进程之前，确认新的 gunicorn 进程已经启动并且与 nginx 正常通信<br>保持整个架构相对简单。当这个项目有更多人在用时，我需要找出性能短板并且想办法水平扩展。但是现在就要考虑到这一点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入 Python 整数对象的实现]]></title>
      <url>http://namco1992.github.io/2015-11-21-realization-of-integer-object-of-python.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文由 伯乐在线 - Namco 翻译，wrm 校稿。未经许可，禁止转载！<br>英文出处：Laurent Luce。欢迎加入翻译组。</p>
</blockquote>
<p>深入 Python 整数对象的实现 <strong><a href="http://www.laurentluce.com/posts/python-integer-objects-implementation/" target="_blank" rel="external">阅读原文 »</a></strong></p>
<p>本文会深入探究 在Python 内部整数对象是如何实现的。</p>
<p>在 Python 内部，一个整数对象是用 PyIntObject 结构来表示的，该整数对象的值属性为 long 型。<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_ival;</span><br><span class="line">&#125; PyIntObject;</span><br></pre></td></tr></table></figure></p>
<p>为了避免每次要用到整数对象的时候都要分配一个新的内存，Python 预先为一批尚未使用的空闲整数对象分配了一块内存。</p>
<p>下面这个结构就是 Python 用来给整数对象分配内存的，这些整数对象又叫作 PyIntObjects 。该结构初始化完成之后，当 Python 脚本中为新的对象赋值的时候就可以直接使用之前分配好的整数对象了。这个结构叫做“PyIntBlock”，定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _intblock &#123;</span><br><span class="line">    <span class="keyword">struct</span> _intblock *next;</span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _intblock PyIntBlock;</span><br></pre></td></tr></table></figure>
<p>Python 在给一批整数对象分配内存块时，这些对象实际上并没有被赋值。我们把这些对象叫做“待用的空闲整数对象”。在 Python 程序中，当一个新的整数值被使用时，这个值就会被赋给下一个可用的整数对象。因为空闲整数对象被赋值的过程中不需要内存分配，所以速度很快。</p>
<p>在同一个块内部的这些整数对象是通过叫做“ob_type”的内部指针从后往前倒序链接在一起的。这里需要注意的是，Python 的源码中存在对内部指针的滥用情况，所以对于指针的名字不用太过纠结。</p>
<p>每一个整数块包含了k个整数对象，k等于 1 KB 的内存块可以容纳的整数对象的数目，在我 64 位电脑上大概是 40 个 PyIntObject 对象。当这个块中所有的整数对象都用完了的时候，就会分配一块新的内存给新的整数对象列表。</p>
<p>已经分配的整数对象内存块是通过一个单向链表来记录的。在Python内部这个列表叫做“block_list”。</p>
<p><img src="http://www.laurentluce.com/images/blog/intobject/1.png" alt="此处输入图片的描述"></p>
<p>在 Python 中使用了一种特殊结构提前为一部分小整数分配了空间，以便快速访问。这是一个包含 262 个指向整数对象的指针的数组（在下文会称之为小整数数组）。这些小整数对象会在（前面提到的）整数对象块进行初始化时被分配，它们的范围是 -5 到 256。许多 Python 程序会频繁使用这一范围内的整数，所以这种预处理的办法非常巧妙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="keyword">static</span> PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br></pre></td></tr></table></figure>
<p><img src="http://www.laurentluce.com/images/blog/intobject/2.png" alt="Python integer object internals"></p>
<p>值为 -5 的整数对象在这个小整数数组中偏移量为0，也就是说位于数组的第一个位置，值为 -4 的整数对象偏移量就是 1，以此类推。</p>
<p>试想一下，在 Python 脚本中定义下面一个整数会发生什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>当你执行第一行的时候，就调用了 PyInt_FromLong 函数，函数逻辑如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if integer value in range -5,256:</span><br><span class="line">    return the integer object pointed by the small integers array at the </span><br><span class="line">    offset (value + 5).</span><br><span class="line">else:</span><br><span class="line">    if no free integer object available:</span><br><span class="line">        allocate new block of integer objects </span><br><span class="line">    set value of the next free integer object in the current block </span><br><span class="line">    of integers.</span><br><span class="line">    return integer object</span><br></pre></td></tr></table></figure>
<p>在我们这个例子中，整数 1 由小整数数组中第 1 + 5 = 6 个指针所指。函数返回指向该整数对象的指针，然后变量“a”就会指向这个整数对象。</p>
<p><img src="http://www.laurentluce.com/images/blog/intobject/3.png" alt="Python integer object internals"></p>
<p>让我们看一下另外一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">300</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure></p>
<p>300 并没有在小整数数组的范围内，所以就需要把一个空的整数对象赋值为 300。</p>
<p><img src="http://www.laurentluce.com/images/blog/intobject/4.png" alt="Python integer object internals"></p>
<p>如果你看过 Python 2.6 源码中的 intobject.c 文件，你就会看到许多处理相加、相乘、转换等运算操作的函数。比如说下面这个比较函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">int_compare</span><span class="params">(PyIntObject *v, PyIntObject *w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> i = v-&amp;gt;ob_ival;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> j = w-&amp;gt;ob_ival;</span><br><span class="line">    <span class="keyword">return</span> (i &amp;lt; j) ? <span class="number">-1</span> : (i &amp;gt; j) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数对象的值储存在对象的 ob_ival 属性中，类型为 long。每个值都存放在一个寄存器中以优化存取过程，所以比较操作是在两个寄存器之间完成的。如果 v 指向的整数对象小于 w 指向的整数对象，返回 -1；反之则返回 1。相等的情况下返回 0。</p>
<p>对 Python 中整数的实现就介绍到这里了。希望你们能喜欢这篇文章并且有所收获。如果你有什么想法就在下方留言吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 的运行时方法补丁技术]]></title>
      <url>http://namco1992.github.io/2015-11-19-Python-running-patch-method.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文由 伯乐在线 - Namco 翻译，赖信涛 校稿。未经许可，禁止转载！<br>英文出处：blog.tryolabs.com。欢迎加入翻译组。</p>
</blockquote>
<p>相信很多朋友在编程的时候都会想修改一下已经写好的程序行为代码，而最常见的方式就是通过子类来重写父类的一些不满足需求的方法。比如说下面这个例子。</p>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print 'Woof!'</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self)</span><br><span class="line">        print 'Howl!'</span><br></pre></td></tr></table></figure>
<p>我们可以用上述方式来修改我们自己写的代码，但是我们应该怎么修改第三方代码呢？当然，我们也可以自己编写一个子类，调用子类的实例对象来实现修改，但是这样可能会引入其他一系列问题。所以我们得想个办法用我们自己的方法替换掉原来的对象方法，这就是本文接下来要介绍的“打补丁”的方式。</p>
<h2 id="给类打补丁"><a href="#给类打补丁" class="headerlink" title="给类打补丁"></a>给类打补丁</h2><p>如果我们想新增或是修改对象的方法的话，最简单的方式莫过于给类打个补丁了。结合上面的例子，如果我们想给我们自己的 Dog 类写一个新的 howl 方法的话，我们可以定义一个新的 howl 函数，像下面的代码一样把它添加到我们的类中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newbark</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Wrooof!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">howl</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Howl!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace an existing method</span></span><br><span class="line">Dog.bark = newbark</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a new method</span></span><br><span class="line">Dog.howl = howl</span><br></pre></td></tr></table></figure>
<p>很简单吧？但是这里有几个问题需要我们注意。首先，被修改的类的所有实例中的方法都会被更新，所以更新后的方法不仅仅存在于新创建的对象中，之前创建的所有对象都会拥有更新之后的方法，除非只是新增而不是覆盖掉原来的方法。第二，你修改或者新增的方法应当是与对象绑定的，所以方法的第一个参数应当是被调用的对象（在这里就是类的实例self）。</p>
<h2 id="给项目打补丁"><a href="#给项目打补丁" class="headerlink" title="给项目打补丁"></a>给项目打补丁</h2><p>单个对象也可以在不影响这个类的其他实例的情况下打补丁。但是还是有点小技巧的哦！先让我们看看下面这个例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">herd</span><span class="params">(self, sheep)</span>:</span></span><br><span class="line">    self.run()</span><br><span class="line">    self.bark()</span><br><span class="line">    self.run()</span><br><span class="line"></span><br><span class="line">border_collie = Dog()</span><br><span class="line">border_collie.herd = herd</span><br></pre></td></tr></table></figure></p>
<p>然后我们再试试调用新定义的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border_collie.herd(sheep)</span><br><span class="line"></span><br><span class="line">TypeError: herd() takes exactly <span class="number">2</span> arguments (<span class="number">1</span> given)</span><br><span class="line">The problem <span class="keyword">with</span> the previous code <span class="keyword">is</span> that the herd <span class="keyword">is</span> <span class="keyword">not</span> a bound method, just take a look at the following code:</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> border_collie.herd</span><br><span class="line"></span><br><span class="line">&lt;function herd at <span class="number">0xf9c5f0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>出错啦！引发错误的原因就是被调用的对象并没有作为第一个参数传给我们写的函数。当然我们可以自己把参数传进去，但是在这个替换类方法的场景下并不奏效。解决这个问题的正确方案是用 type 这个模块里的 MethodType 函数，我们可以看看下面的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line"></span><br><span class="line">border_collie = Dog()</span><br><span class="line">border_collie.herd  = types.MethodType(herd, border_collie)</span><br><span class="line"></span><br><span class="line">print border_collie.herd</span><br></pre></td></tr></table></figure></p>
<p>现在我们的方法已经和实例绑定了，大功告成！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>运行中替换或者添加方法是非常有用的，比如说在单元测试中，有些负责和外界服务通信的函数就需要替换掉，方便测试。这个技巧不仅很常用，而且在你最终决定要修改代码之前还可以保持代码的可维护性，是一个非常重要的技巧。</p>
]]></content>
    </entry>
    
  
  
</search>
